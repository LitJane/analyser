from __future__ import print_function
# -*- coding: utf-8 -*-

"""UI-Demo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dEizre5ZjU6wEY0_-GyYOH9ocNNroqjE

#.init

* Widgets: https://colab.research.google.com/notebooks/widgets.ipynb
* Advanced output: https://colab.research.google.com/notebooks/snippets/advanced_outputs.ipynb

##utils
"""

import IPython
import uuid
from google.colab import output
from google.colab import files



from google.colab import widgets
from google.colab import output



# from google.colab import files

def interactive_upload(filetype):
  
  import docx2txt
  
  print(f'Please select "{filetype}" .docx file:')
  uploaded = files.upload()
  docs=[]
  for fn in uploaded.keys():
    print('User uploaded file "{name}" with length {length} bytes'.format(
        name=fn, length=len(uploaded[fn])))

    with open(fn, "wb") as df:
      df.write(uploaded[fn])
      df.close()

    # extract text
  
    text = ''
    try:
      text = docx2txt.process(fn)
    except:
      print("Unexpected error:", sys.exc_info())
      os.system('antiword -w 0 "' + fn + '" > "' + fn + '.txt"')
      with open(fn + '.txt') as f:
        text = f.read()
    print("–°–∏–º–≤–æ–ª–æ–≤ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–º –¥–æ–∫—É–º–µ–Ω—Ç–µ:", len(text))
    docs.append(text)
    return docs
  
  
  
  
class InvokeButton(object):
  def __init__(self, title, callback = None):
    self.title = title
    self.callback = callback

#   def _repr_html_(self):
  def render(self):
    self.callback_id = 'button-' + str(uuid.uuid4())
    if self.callback:
      output.register_callback(self.callback_id, self.callback)

    template =f'''<li><button style="padding:5px; font-size:16px; margin:15px"  id="{self.callback_id}">{self.title}</button></li>
        <script>
          document.querySelector("#{self.callback_id}").onclick = (e) => {{
            google.colab.kernel.invokeFunction("{self.callback_id}", [], {{}})
            e.preventDefault();
          }};
        </script>'''
    display(IPython.display.HTML(template))
    
def upload_file_b(tb, type):
  with output.redirect_to_element('#upload_area'): 
  
    print(f'–ó–∞–≥—Ä—É–∑–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞ —Ç–∏–ø–∞ "{type}"')
    print('Select .docx files:')
    uploaded = interactive_upload(type)

#   with tb.output_to(type):
#     for fn in uploaded:
#       print(f'User uploaded file "{fn[0:1000]}" with length {len(fn)} bytes')

def clear_div(elementID):
  display(IPython.display.Javascript(f'document.getElementById("{elementID}").innerHTML = "";'))

def replace_self_elem(elementID, text):
  #print(f'Replace: {elementID}')
  display(IPython.display.Javascript(f'document.getElementById("{elementID}").parentElement.innerHTML = "{text}";'))


def call_invoke(title, callback):
  with output.redirect_to_element('#items'):    
    InvokeButton(title, callback).render()
    
  clear_div("upload_area")
  
  
GLOBALS__ = {}

"""#–î–µ–º–æ"""

#@title –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤

#=========================
_git_branch='demo-2-fixed'
#=========================

import os
import sys


def interactive_upload(filetype):
  from google.colab import files
  import docx2txt
  
  print(f'Please select "{filetype}" .docx file:')
  uploaded = files.upload()
  docs=[]
  for fn in uploaded.keys():
    print('User uploaded file "{name}" with length {length} bytes'.format(
        name=fn, length=len(uploaded[fn])))

    with open(fn, "wb") as df:
      df.write(uploaded[fn])
      df.close()

    # extract text
  
    text = ''
    try:
      text = docx2txt.process(fn)
    except:
      print("Unexpected error:", sys.exc_info())
      os.system('antiword -w 0 "' + fn + '" > "' + fn + '.txt"')
      with open(fn + '.txt') as f:
        text = f.read()
    print("–°–∏–º–≤–æ–ª–æ–≤ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–º –¥–æ–∫—É–º–µ–Ω—Ç–µ:", len(text))
    docs.append(text)
    return docs



# AZ:-IMPORT CODE GITHUB-----------------------------------------------------------------------------------

def _init_import_code_from_gh():
  if '_init_import_code_from_gh' in GLOBALS__:
    print('üëå code already imported from GitHub!')
    return

  print(f"fetching code from GitHub.....{_git_branch}")
  l1 = 'rm -r nlp_tools'
  l2 = f'git clone --single-branch --branch {_git_branch} https://github.com/compartia/nlp_tools.git nlp_tools'
  os.system(l1)
  os.system(l2)
  import subprocess
  r = subprocess.check_output('cd nlp_tools\ngit rev-list --reverse HEAD | awk "{ print NR }" | tail -n 1\ngit branch',
                              shell=True)
  print('ü¶ä GIT revision:', str(r).replace('\\n', '\t'))

  sys.path.insert(0, 'nlp_tools')

  # self-test
  from text_tools import untokenize
  untokenize(['code', 'ok'])
  print(untokenize(['code', 'imported', 'OK üëç']))

  print('installing antiword...')
  r = subprocess.check_output('sudo apt-get install antiword', shell=True)
  print(r)

  print('installing docx2txt...')
  r = subprocess.check_output("pip install docx2txt", shell=True)
  r = print(r)
  print(r)
  GLOBALS__['_init_import_code_from_gh'] = True
  print('‚ù§Ô∏è DONE importing Code fro GitHub')

  

  

#AZ:-INIT ELMO-----------------------------------------------------------------------------------
import tensorflow as tf
import tensorflow_hub as hub



def _import_elmo():
  if 'elmo' in GLOBALS__:
    print('üëå Tensorflow hub.Module is already imported ')
    return GLOBALS__['elmo']
    
  elmo = hub.Module('https://storage.googleapis.com/az-nlp/elmo_ru-news_wmt11-16_1.5M_steps.tar.gz', trainable=False) #twitter
  print('‚ù§Ô∏è DONE importing Tensorflow hub.Module ')
  print('Tensorflow version is', tf.__version__)
  GLOBALS__['elmo']=elmo

  print(GLOBALS__['elmo'].__dict__)
  return GLOBALS__['elmo']
  
#AZ:-INIT EMBEDDER-----------------------------------------------------------------------------------

def _init_embedder():
  
  if 'elmo_embedder' in GLOBALS__:
    print('üëå Embedder is already created! ')
    return

  elmo = _import_elmo()
  
  from embedding_tools import ElmoEmbedder
  GLOBALS__['elmo_embedder'] = ElmoEmbedder(elmo, tf, 'elmo')
  
  print('‚ù§Ô∏è DONE creating words embedding model')
  return GLOBALS__['elmo_embedder']



#AZ:-Init chartes context-----------------------------------------------------------------------------------
def _init_charters():
  if 'CharterAnlysingContext' in GLOBALS__:
    print('üëå Charters-related tools are already inited ')
    return 

  from demo_charter import CharterAnlysingContext  
  GLOBALS__['CharterAnlysingContext'] = CharterAnlysingContext(GLOBALS__['elmo_embedder'], GLOBALS__['renderer'])
  print('‚ù§Ô∏è DONE initing Charters-related tools and models ')
  
  
  
  
  
def _init_contracts():
  if 'ContractAnlysingContext' in GLOBALS__:
    print('üëå Contracts-related tools are already inited ')
    return 

  from demo import ContractAnlysingContext   
  GLOBALS__['ContractAnlysingContext'] = ContractAnlysingContext(GLOBALS__['elmo_embedder'], GLOBALS__['renderer'])
  print('‚ù§Ô∏è DONE initing Contracts-related tools and models ')
  
  
  
  

  
#AZ:- THE CODE----------------------------------------------------------------------------------
def _init_the_code():
  if '_init_the_code' in GLOBALS__:
    print('üëå Code is alredy imported!')
    return 
  
  
  import matplotlib as mpl
  from IPython.core.display import display, HTML
  import matplotlib.pyplot as plt
  from renderer import AbstractRenderer, head_types_colors
  from transaction_values import ValueConstraint
  
  from demo_charter import head_types_dict, head_types

  
  class DemoRenderer(AbstractRenderer):
    
    def sign_to_text(self, sign: int):
      if sign < 0: return " &lt; "
      if sign > 0: return " &gt; "
      return ' = '

    def value_to_html(self, vc: ValueConstraint):
      color = '#333333'
      if vc.sign > 0:
        color = '#993300'
      elif vc.sign < 0:
        color = '#009933'

      return f'<b style="color:{color}">{self.sign_to_text(vc.sign)} {vc.currency} {vc.value:20,.2f}</b> '


    def render_values(self, values):
      
      if len(values)>0:
        for p in values:
          h = self.value_to_html(p)
          display(HTML(h))
      else:
        display(HTML('—Å—É–º–º–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'))
    
    def render_contents(self, doc):
      html='<h3>–í—ã—è–≤–ª–µ–Ω–Ω–æ–µ –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞</h4>'
      html+="<ul>"
      for i in doc.structure.headline_indexes:
        line = doc.structure.structure[i].to_string(doc.tokens_cc)
        html+=f'<li> {line} <sup>line {i}</sup></li>'
      html+="</ul>"
 
  
      display(HTML(html))

    def render_value_section_details(self, value_section_info):
      value_section = value_section_info.body
      headline_doc = value_section_info.subdoc

      headline = headline_doc.untokenize_cc()

      v_names = {
        'value_attention_vector',
        'novalue_attention_vector',

        'novalue_attention_vector_local_contrast',
        'value_attention_vector_tuned'}

      fig = plt.figure(figsize=(20, 6))
      ax = plt.axes()
      for vector_name in v_names:
        ax.plot(value_section.distances_per_pattern_dict[vector_name], label=vector_name, alpha=0.4);
      ax.plot(value_section.distances_per_pattern_dict['value_attention_vector_tuned'], label=vector_name.upper(),
              alpha=0.9, color='black');
      plt.legend(loc='upper right')

      text = self.to_color_text(value_section.tokens_cc,
                           value_section.distances_per_pattern_dict['value_attention_vector_tuned'], _range=(0, 1))
      html = f'<h3>{headline}</h3> <div style="margin-left:4em; font-size=90%">{text}</div>'
      display(HTML(html))

    def to_color_text(self,tokens, weights, colormap='coolwarm', print_debug=False, _range=None):
      if len(tokens) == 0:
        return " - empty -"
      if len(weights) != len(tokens):
        raise ValueError("number of weights differs weights={} tokens={}".format(len(weights), len(tokens)))

      #   if()
      vmin = weights.min()
      vmax = weights.max()

      if _range is not None:
        vmin = _range[0]
        vmax = _range[1]

      if print_debug:
        print(vmin, vmax)

      norm = mpl.colors.Normalize(vmin=vmin - 0.5, vmax=vmax)
      html = ""
      cmap = mpl.cm.get_cmap(colormap)

      for d in range(0, len(weights)):
        word = tokens[d]
        if word == ' ':
          word = '&nbsp;_ '

        html += '<span title="{} {:.4f}" style="background-color:{}">{} </span>'.format(
          d,
          weights[d],
          mpl.colors.to_hex(cmap(norm(weights[d]))),
          word)

        #     html+='<span style="background-color:' +mpl.colors.to_hex(cmap(norm(weights[d]) ))+ '">' + str(tokens[d]) + " </span>"
        if tokens[d] == '\n':
          html += "<br>"

      return html
    
    def _render_sentence(self, sentence):
      html = ""
      constraints:List[ValueConstraint] = sentence['constraints']
      for c in constraints:
        html += self.value_to_html(c)

      if len(constraints) > 0:
        html += '<div style="border-bottom:1px solid #ccc; margin-top:1em"></div>'
        section = sentence['subdoc']
        html += self.to_color_text(section.tokens, section.distances_per_pattern_dict['deal_value_attention_vector'])
      return html

    


    def render_constraint_values(self, rz):
      head_types = ['head.directors', 'head.all', 'head.gen', 'head.pravlenie']

      head_types_dict = {  'head.directors':'–°–æ–≤–µ—Ç –¥–∏—Ä–µ–∫—Ç–æ—Ä–æ–≤', 
                           'head.all':'–û–±—â–µ–µ —Å–æ–±—Ä–∞–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤/–∞–∫—Ü–∏–æ–Ω–µ—Ä–æ–≤', 
                           'head.gen':'–ì–µ–Ω–µ—Ä–∞–ª—å–Ω—ã–π –¥–∏—Ä–µ–∫—Ç–æ—Ä', 
      #                      'shareholders':'–û–±—â–µ–µ —Å–æ–±—Ä–∞–Ω–∏–µ –∞–∫—Ü–∏–æ–Ω–µ—Ä–æ–≤', 
                           'head.pravlenie':'–ü—Ä–∞–≤–ª–µ–Ω–∏–µ –æ–±—â–µ—Å—Ç–≤–∞',
                           'head.unknown':'*–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –æ—Ä–≥–∞–Ω —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è*'}

      


      org_types={
          'org_unknown':'undefined', 
          'org_ao':'–ê–∫—Ü–∏–æ–Ω–µ—Ä–Ω–æ–µ –æ–±—â–µ—Å—Ç–≤–æ', 
          'org_zao':'–ó–∞–∫—Ä—ã—Ç–æ–µ –∞–∫—Ü–∏–æ–Ω–µ—Ä–Ω–æ–µ –æ–±—â–µ—Å—Ç–≤–æ', 
          'org_oao':'–û—Ç–∫—Ä—ã—Ç–æ–µ –∞–∫—Ü–∏–æ–Ω–µ—Ä–Ω–æ–µ –æ–±—â–µ—Å—Ç–≤–æ', 
          'org_ooo':'–û–±—â–µ—Å—Ç–≤–æ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–π –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å—é'}
      
      html = ''
      for head_type in rz.keys():

        r_by_head_type = rz[head_type]

        html += '<hr style="margin-top: 45px">'
        html += '<i style="padding:0; margin:0">—Ä–µ—à–µ–Ω–∏—è –æ –ø–æ—Ä–æ–≥–æ–≤—ã—Ö —Å—É–º–º–∞—Ö, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç</i><h2 style="color:{}; padding:0;margin:0">{}</h2>'.format(
          head_types_colors[head_type],
          head_types_dict[head_type])

        sentences = r_by_head_type['sentences']
        html += '<h4>{}</h4>'.format(r_by_head_type['caption'])
        html += '<div style="padding-left:80px">'

        if True:
          if len(sentences) > 0:
            for sentence in sentences:
              html += self._render_sentence(sentence)

          else:
            html += '<h4 style="color:crimson">–ü–æ—Ä–æ–≥–æ–≤—ã–µ —Å—É–º–º—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –∏–ª–∏ –Ω–µ –∑–∞–¥–∞–Ω—ã</h4>'

        html += '</div>'

      return html
    
    def render_charter_parsing_results(self, org, rz):
      txt_html = self.to_color_text(org['tokens'], org['attention_vector'], _range=[0, 1])

      html = '<div style="background:#eeeeff; padding:0.5em"> recognized NE(s): <br><br> org type:<h3 style="margin:0">  {} </h3>org full name:<h2 style="margin:0">  {} </h2> <br>quote: <div style="font-size:90%; background:white">{}</div> </div>'.format(
        org['type_name'], org['name'], txt_html)
      # html+=txt_html
      html += self.render_constraint_values(rz)

      display(HTML(html))

    def render_color_text(self,tokens, weights, colormap='coolwarm', print_debug=False, _range=None):
      html = self.to_color_text(tokens, weights, colormap, print_debug, _range)
      display(HTML(html))



    def print_results(self,doc, results):
      result, (start, end), sentence, meta = results

      html = "<hr>"

      html += self._render_doc_subject_fragments(doc)

      if result is None:
        html += '<h2 style="color:red">–°–£–ú–ú–ê –ù–ï –ù–ê–ô–î–ï–ù–ê</h2>'
      else:
        html += '<h2>' + str(result[0]) + ' ' + str(result[1]) + '</h2>'

      for key in meta.keys():
        html += '<div style="font-size:9px">' + str(key) + " = " + str(meta[key]) + "</div>"

      display(HTML(html))
      self.render_color_text(doc.tokens[start:end], doc.sums[start:end])
  
  
  
  GLOBALS__['renderer'] = DemoRenderer()

  
  GLOBALS__['_init_the_code'] = True
  
  
  
    
  #AZ:--------------------------------------------------Init chartes context==== 
  
  
  
  
  
  def read_doc(fn):
    import docx2txt, sys, os
    text = ''
    try:
      text = docx2txt.process(fn)
    except:
      print("Unexpected error:", sys.exc_info())
      os.system('antiword -w 0 "' + fn + '" > "' + fn + '.txt"')
      with open(fn + '.txt') as f:
        text = f.read()

    return text
  
  GLOBALS__['read_doc']=read_doc

  print("‚ù§Ô∏è DONE initializing the code")
  
  
      





#AZ:- ENDO OF THE THE CODE-----------------------------------------------------------------------------------





  

  
def start_wizard(tb):
  def step1():
    #replace_self_elem(b1.callback_id, '') 
    with tb.output_to(0):
      print(f"\033[1;32m–°–º. —Å–ª–µ–¥—É—é—â–∏–µ —Ç–∞–±—ã\u2713")
    
    with tb.output_to(1):
      
      uploaded = interactive_upload('–£—Å—Ç–∞–≤')
      
      try:
        GLOBALS__['CharterAnlysingContext'].analyze_charter(uploaded[0], True)       
        doc = GLOBALS__['CharterAnlysingContext'].doc
        GLOBALS__['renderer'].render_contents(doc)
          
        org, rz = GLOBALS__['CharterAnlysingContext'] .analyze_charter(uploaded[0])
        GLOBALS__['renderer'].render_charter_parsing_results(org,rz)
          
      except Exception as e:
        print('ERROR:',e)
      
      
      print(f"\033[1;32m–®–∞–≥1: —Å–¥–µ–ª–∞–Ω–æ\u2713")  
      b2.render()

  def step2():
    replace_self_elem(b2.callback_id, '')   
    with tb.output_to(2):
      print('TAB2')
      
      uploaded = interactive_upload('–î–æ–≥–æ–≤–æ—Ä')            
      try:
        GLOBALS__['ContractAnlysingContext'].analyze_contract(uploaded[0])        
        doc = GLOBALS__['ContractAnlysingContext'].contract
        GLOBALS__['renderer'].render_contents(doc)
   
      except Exception as e:
        print('ERROR:',e)
      
      print(f"\033[1;32m–®–∞–≥2: —Å–¥–µ–ª–∞–Ω–æ\u2713")  
      b3.render()

  def step3():    
    replace_self_elem(b3.callback_id, '')   
    with tb.output_to(3):
      print('TAB3')
#       uploaded = upload_file()
      
      ## do something 
      print('–ü–æ–∏—Å–∫ –Ω–∞—Ä—É—à–µ–Ω–∏–π')
      GLOBALS__['renderer'].render_values(GLOBALS__['ContractAnlysingContext'].contract_values)
#       GLOBALS__['renderer'].render_charter_parsing_results(GLOBALS__['CharterAnlysingContext'].org, GLOBALS__['CharterAnlysingContext'].constraints)
      from IPython.core.display import display, HTML
      h = GLOBALS__['renderer'].render_constraint_values(GLOBALS__['CharterAnlysingContext'].constraints)
      display(HTML(h))
      
      
      print(f"\033[1;32m–®–∞–≥3: —Å–¥–µ–ª–∞–Ω–æ\u2713")  
      b4.render()

  def step4():
    replace_self_elem(b4.callback_id, '')   
    with tb.output_to(4):
      print('TAB4')
      
      ## do something here 
      
      print(f"\033[1;32m–®–∞–≥4: —Å–¥–µ–ª–∞–Ω–æ\u2713")  
      
  b1 = InvokeButton('–ù–∞—á–∞—Ç—å', step1)
  b2 = InvokeButton('–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å', step2)
  b3 = InvokeButton('–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å', step3)
  b4 = InvokeButton('–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å', step4)
  
  with tb.output_to(0): 
    try:     
      
      ## do preparation here   

      #1.
      _init_import_code_from_gh()
      #2.
      _init_embedder()
      #3.
      _init_the_code()
      #4. 
      _init_charters()
      #5.
      _init_contracts()

      b1.render()
    except:
      print("ERROR:", sys.exc_info())    


    
    
    
    
   
    
#@title Wizard2
tb2 = widgets.TabBar(['–ù–∞—á–∞–ª–æ', '–£—Å—Ç–∞–≤', '–î–æ–≥–æ–≤–æ—Ä', '–ü–æ–∏—Å–∫ –Ω–∞—Ä—É—à–µ–Ω–∏–π', '–ü—Ä–æ—Ç–æ–∫–æ–ª'], location='top')    
start_wizard(tb2)

# constraints = GLOBALS__['CharterAnlysingContext'].constraints

# GLOBALS__['renderer'].render_values(GLOBALS__['ContractAnlysingContext'].contract_values)
# GLOBALS__['renderer'].render_charter_parsing_results(GLOBALS__['CharterAnlysingContext'].org, GLOBALS__['CharterAnlysingContext'].constraints)


# # for i in 

# for headkey in constraints:
#   cc = constraints[headkey]
#   print (cc)
#   print (cc['section'])
#   print (cc['caption'])
  
#   for s in cc['sentences']:
#     print ('\t\t',s['constraints'])
#     c = s['constraints']
#     for vc in c:
#       print(f'\t\t\t {vc.value} \t {vc.sign} \t {vc.currency}')

GLOBALS__['ContractAnlysingContext'].analyze_contract(GLOBALS__['ContractAnlysingContext'].contract.untokenize_cc() )

doc = GLOBALS__['CharterAnlysingContext'].doc
from IPython.core.display import display, HTML


def render_contents(doc):
  html='<h3>–í—ã—è–≤–ª–µ–Ω–Ω–æ–µ –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞</h4>'
  html+="<ul>"
  for i in doc.structure.headline_indexes:
    line = doc.structure.structure[i].to_string(doc.tokens_cc)
    html+=f'<li> {line} <sup>line {i}</sup></li>'
  html+="</ul>"
 
  
  display(HTML(html))
    
render_contents(doc)

print(GLOBALS__['ContractAnlysingContext'].contract)
